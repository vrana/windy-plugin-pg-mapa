<plugin>
<script>
import broadcast from '@windy/broadcast';
import interpolator from '@windy/interpolator';
import map from '@windy/map';
import pluginDataLoader from '@windy/pluginDataLoader';
import store from '@windy/store';
import utils from '@windy/utils';

const loadData = pluginDataLoader({
	key: 'vVGMVsbSz6cWtZsxMPQURL88LKFYpojx',
	plugin: 'windy-plugin-pg-mapa',
});

const sites = {};
const markers = {};
const winds = {};
const forecasts = {};

this.onopen = () => {
	if (Object.keys(sites).length) {
		for (const lat in markers) {
			for (const lon in markers[lat]) {
				markers[lat][lon].addTo(map);
			}
		}
		return;
	}
	fetch('https://www.paragliding-mapa.cz/api/v0.1/launch').then(response => response.json()).then(launch => {
		launchLoop: for (const site of launch.data) {
			for (const lat in sites) {
				for (const lon in sites[lat]) {
					if (utils.isNear({lat, lon}, {lat: site.latitude, lon: site.longitude})) {
						sites[lat][lon].push(site);
						continue launchLoop;
					}
				}
			}
			sites[site.latitude] = sites[site.latitude] || {};
			sites[site.latitude][site.longitude] = [site];
		}
		
		for (const lat in sites) {
			for (const lon in sites[lat]) {
				const icon = newIcon(getIconUrl(sites[lat][lon], null), map.getZoom());
				const marker = L.marker([lat, lon], {icon, riseOnHover: true}).addTo(map);
				marker.bindPopup(getTooltip(sites[lat][lon]));
				marker.on('mouseover', () => marker.openPopup());
				marker.on('popupopen', () => loadForecast(lat, lon));
				markers[lat] = markers[lat] || {};
				markers[lat][lon] = marker;
			}
		}
		
		redraw();
		broadcast.on('redrawFinished', redraw);
	});
};

this.onclose = () => {
	for (const lat in markers) {
		for (const lon in markers[lat]) {
			map.removeLayer(markers[lat][lon]);
		}
	}
};

function redraw() {
	interpolator(interpolate => {
		for (const lat in markers) {
			for (const lon in markers[lat]) {
				if (map.getBounds().contains(L.latLng(lat, lon))) {
					let wind;
					if (store.get('overlay') == 'wind') {
						const data = interpolate({lat, lon});
						wind = data && utils.wind2obj(data);
					} else if (loadForecast(lat, lon)) {
						const data = getForecast(forecasts[getModel()][lat][lon]);
						wind = data && {wind: data.wind, dir: data.windDir};
					}
					if (winds[lat]) {
						delete winds[lat][lon];
					}
					if (!wind) {
						const url = markers[lat][lon]._icon.src;
						markers[lat][lon].setIcon(newIcon(url, map.getZoom()));
					} else {
						updateMarker(lat, lon, wind);
					}
				}
			}
		}
	});
}

function loadForecast(lat, lon) {
	const model = getModel();
	forecasts[model] = forecasts[model] || {};
	forecasts[model][lat] = forecasts[model][lat] || {};
	if (forecasts[model][lat][lon]) {
		return true;
	}
	loadData('forecast', {model, lat: +lat, lon: +lon}).then(forecast => {
		forecasts[model][lat][lon] = forecast.data;
		const data = getForecast(forecast.data);
		updateMarker(lat, lon, data && {wind: data.wind, dir: data.windDir});
	});
}

function updateMarker(lat, lon, wind) {
	winds[lat] = winds[lat] || {};
	winds[lat][lon] = winds[lat][lon] || wind;
	wind = winds[lat][lon];
	markers[lat][lon].setIcon(newIcon(getIconUrl(sites[lat][lon], wind), map.getZoom()));
	markers[lat][lon].setOpacity(getColor(sites[lat][lon], wind) != 'red' ? 1 : .4);
	markers[lat][lon].setPopupContent(getTooltip(sites[lat][lon]));
}

function getTooltip(sites) {
	let wind;
	let forecast;
	const tooltips = sites.map(site => {
		wind = wind || (winds[site.latitude] && winds[site.latitude][site.longitude]);
		forecast = forecast || (forecasts[getModel()] && forecasts[getModel()][site.latitude] && forecasts[getModel()][site.latitude][site.longitude]);
		return '<a href="' + site.url + '" target="_blank">' + html(site.name) + '</a> (' + site.superelevation + ' m)';
	});
	const extra = [];
	if (wind) {
		extra.push(wind.dir + 'Â° ' + wind.wind.toFixed(1) + ' m/s');
	}
	if (forecast && !/FAKE/.test(forecast.header.note)) {
		const data = getForecast(forecast);
		if (data) {
			const sunrise = new Date(forecast.header.sunrise).getHours();
			const sunset = new Date(forecast.header.sunset).getHours();
			const icon = data.icon2 + (data.hour > sunrise && data.hour <= sunset ? '' : '_night_' + data.moonPhase);
			extra.push('<img src="img/icons4/png_25px/' + icon + '.png" style="height: 1.3em; vertical-align: middle;">' + (data.mm ? ' ' + data.mm + ' mm' : ''));
		}
	}
	if (extra.length) {
		tooltips.push(extra.join(' '));
	}
	return '<div style="min-width: 150px;">' + tooltips.join('<br>') + '</div>';
}

function getModel() {
	return store.get('product') == 'gfs' ? 'gfs' : 'ecmwf';
}

function getForecast(forecast) {
	const path = store.get('path').replace(/\//g, '-');
	const day = forecast.data[path.replace(/-\d+$/, '')] || [];
	for (const data of day) {
		if (data.hour >= path.replace(/.*-0?/, '')) {
			return data;
		}
	}
}

function getColor(sites, wind) {
	if (!wind) {
		return 'white';
	}
	if (wind.wind.toFixed(1) >= 8) {
		return 'red';
	}
	const dir = wind.dir;
	let color = 'red';
	for (const site of sites) {
		const from = site.wind_usable_from;
		const to = site.wind_usable_to;
		if (isDirIn(dir, from, to)) {
			return wind.wind.toFixed(1) >= 4 ? 'yellow' : 'lime';
		}
		if (isDirIn(dir, from, to, 10)) {
			color = 'yellow';
		}
	}
	return color;
}

function isDirIn(dir, from, to, tolerance = 0) {
	to += (to < from ? 360 : 0);
	return (dir >= from - tolerance && dir <= to + tolerance) || dir <= to + tolerance - 360 || dir >= from - tolerance + 360;
}

function getIconUrl(sites, wind) {
	let svg = '<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38">\n';
	for (const site of sites) {
		svg += getCircleSlice(site.wind_usable_from - 90, site.wind_usable_to - 90, 38, getColor([site], wind)) + '\n';
	}
	svg += '<circle cx="19" cy="19" r="18" stroke="white" stroke-width="2" fill-opacity="0"/>\n</svg>';
	return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function newIcon(url, zoom) {
	const size = zoom > 9 ? 38 : zoom > 6 ? 19 : zoom > 4 ? 9 : 5;
	return L.icon({
		iconUrl: url,
		iconSize: [size, size],
		iconAnchor: [(size - 1) / 2, (size - 1) / 2],
	});
}

function getCircleSlice(startAngle, endAngle, size, color) {
	const hSize = size / 2;
	const x1 = Math.round(hSize + hSize * Math.cos(Math.PI * startAngle / 180));
	const y1 = Math.round(hSize + hSize * Math.sin(Math.PI * startAngle / 180));
	const x2 = Math.round(hSize + hSize * Math.cos(Math.PI * endAngle / 180));
	const y2 = Math.round(hSize + hSize * Math.sin(Math.PI * endAngle / 180));
	return "<path d='M" + hSize + "," + hSize + " L" + x1 + "," + y1 + " A" + hSize + "," + hSize + " 0 0,1 " + x2 + "," + y2 + " z' fill='" + color + "'/>";
}

function html(s) {
	return s.replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
</script>
</plugin>
