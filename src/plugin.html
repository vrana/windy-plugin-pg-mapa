<plugin>
<script>
import broadcast from '@windy/broadcast';
import interpolator from '@windy/interpolator';
import map from '@windy/map';
import pluginDataLoader from '@windy/pluginDataLoader';
import store from '@windy/store';
import utils from '@windy/utils';

const loadData = pluginDataLoader({
	key: 'vVGMVsbSz6cWtZsxMPQURL88LKFYpojx',
	plugin: 'windy-plugin-pg-mapa',
});

const markers = {};
const winds = {};
const forecasts = {};

this.onopen = () => {
	fetch('https://www.paragliding-mapa.cz/api/v0.1/launch').then(response => response.json()).then(launch => {
		const sites = {};
		launchLoop: for (const site of launch.data) {
			for (const lat in sites) {
				for (const lon in sites[lat]) {
					if (utils.isNear({lat, lon}, {lat: site.latitude, lon: site.longitude})) {
						sites[lat][lon].push(site);
						continue launchLoop;
					}
				}
			}
			sites[site.latitude] = sites[site.latitude] || {};
			sites[site.latitude][site.longitude] = [site];
		}
		
		function getTooltip(sites) {
			return () => {
				let wind;
				let forecast;
				const tooltips = sites.map(site => {
					wind = wind || (winds[site.latitude] && winds[site.latitude][site.longitude]);
					forecast = forecast || (forecasts[site.latitude] && forecasts[site.latitude][site.longitude]);
					return '<a href="' + site.url + '" target="_blank">' + html(site.name) + '</a> (' + site.superelevation + ' m)';
				});
				const extra = [];
				if (wind) {
					extra.push(wind);
				}
				if (forecast && !/FAKE/.test(forecast.header.note)) {
					const path = store.get('path').replace(/\//g, '-');
					const sunrise = new Date(forecast.header.sunrise).getHours();
					const sunset = new Date(forecast.header.sunset).getHours();
					for (const date in forecast.data) {
						if (path.startsWith(date)) {
							for (const data of forecast.data[date]) {
								if (data.hour == path.replace(/.*-0?/, '')) {
									extra.push(data.rain ? 'ðŸŒ§ ' + data.mm + ' mm' : (data.hour > sunrise && data.hour <= sunset ? 'â˜€' : 'â˜¾'));
									break;
								}
							}
							break;
						}
					}
				}
				if (extra.length) {
					tooltips.push(extra.join(' '));
				}
				return '<div style="min-width: 150px;">' + tooltips.join('<br>') + '</div>';
			};
		}
		
		for (const lat in sites) {
			for (const lon in sites[lat]) {
				const tooltip = getTooltip(sites[lat][lon]);
				const icon = newIcon(getIconUrl(sites[lat][lon], null), map.getZoom());
				const marker = L.marker([lat, lon], {icon, riseOnHover: true}).addTo(map);
				marker.bindPopup(tooltip);
				marker.on('mouseover', () => marker.openPopup());
				marker.on('popupopen', () => {
					forecasts[lat] = forecasts[lat] || {};
					if (!forecasts[lat][lon]) {
						loadData('forecast', {model: store.get('product') == 'gfs' ? 'gfs' : 'ecmwf', lat: +lat, lon: +lon}).then(forecast => {
							forecasts[lat][lon] = forecast.data;
							marker.setPopupContent(tooltip());
						});
					}
				});
				markers[lat] = markers[lat] || {};
				markers[lat][lon] = marker;
			}
		}
		
		function redraw() {
			interpolator(interpolate => {
				for (const lat in markers) {
					for (const lon in markers[lat]) {
						if (map.getBounds().contains(L.latLng(lat, lon))) {
							if (store.get('overlay') != 'wind') {
								const url = markers[lat][lon]._icon.src;
								markers[lat][lon].setIcon(newIcon(url, map.getZoom()));
							} else {
								const data = interpolate({lat, lon});
								const wind = (data ? utils.wind2obj(data) : null);
								markers[lat][lon].setIcon(newIcon(getIconUrl(sites[lat][lon], wind), map.getZoom()));
								winds[lat] = winds[lat] || {};
								winds[lat][lon] = (wind ? wind.dir + 'Â° ' + wind.wind.toFixed(1) + ' m/s' : '');
								markers[lat][lon].setOpacity(getColor(sites[lat][lon], wind) != 'red' ? 1 : .4);
								markers[lat][lon].setPopupContent(getTooltip(sites[lat][lon])());
							}
						}
					}
				}
			});
		}
		
		redraw();
		
		broadcast.on('redrawFinished', redraw);
	});
};

this.onclose = () => {
	for (const lat in markers) {
		for (const lon in markers[lat]) {
			map.removeLayer(markers[lat][lon]);
		}
	}
};

function getColor(sites, wind) {
	if (!wind) {
		return 'white';
	}
	if (wind.wind.toFixed(1) >= 8) {
		return 'red';
	}
	const dir = wind.dir;
	let color = 'red';
	for (const site of sites) {
		const from = site.wind_usable_from;
		const to = site.wind_usable_to;
		if (isDirIn(dir, from, to)) {
			return wind.wind.toFixed(1) >= 4 ? 'yellow' : 'lime';
		}
		if (isDirIn(dir, from, to, 10)) {
			color = 'yellow';
		}
	}
	return color;
}

function isDirIn(dir, from, to, tolerance = 0) {
	to += (to < from ? 360 : 0);
	return (dir >= from - tolerance && dir <= to + tolerance) || dir <= to + tolerance - 360 || dir >= from - tolerance + 360;
}

function getIconUrl(sites, wind) {
	let svg = '<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38">\n';
	for (const site of sites) {
		svg += getCircleSlice(site.wind_usable_from - 90, site.wind_usable_to - 90, 38, getColor([site], wind)) + '\n';
	}
	svg += '<circle cx="19" cy="19" r="18" stroke="white" stroke-width="2" fill-opacity="0"/>\n</svg>';
	return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function newIcon(url, zoom) {
	const size = zoom > 9 ? 38 : zoom > 6 ? 19 : zoom > 4 ? 9 : 5;
	return L.icon({
		iconUrl: url,
		iconSize: [size, size],
		iconAnchor: [(size - 1) / 2, (size - 1) / 2],
	});
}

function getCircleSlice(startAngle, endAngle, size, color) {
	const hSize = size / 2;
	const x1 = Math.round(hSize + hSize * Math.cos(Math.PI * startAngle / 180));
	const y1 = Math.round(hSize + hSize * Math.sin(Math.PI * startAngle / 180));
	const x2 = Math.round(hSize + hSize * Math.cos(Math.PI * endAngle / 180));
	const y2 = Math.round(hSize + hSize * Math.sin(Math.PI * endAngle / 180));
	return "<path d='M" + hSize + "," + hSize + " L" + x1 + "," + y1 + " A" + hSize + "," + hSize + " 0 0,1 " + x2 + "," + y2 + " z' fill='" + color + "'/>";
}

function html(s) {
	return s.replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
</script>
</plugin>
