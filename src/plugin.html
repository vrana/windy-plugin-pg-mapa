<plugin>
<script>
import broadcast from '@windy/broadcast';
import interpolator from '@windy/interpolator';
import map from '@windy/map';
import pluginDataLoader from '@windy/pluginDataLoader';
import store from '@windy/store';
import utils from '@windy/utils';

const loadData = pluginDataLoader({
	key: 'vVGMVsbSz6cWtZsxMPQURL88LKFYpojx',
	plugin: 'windy-plugin-pg-mapa',
});

const sites = {};
const markers = {};
const winds = {};
const forecasts = {};

this.onopen = () => {
	if (Object.keys(markers).length) {
		for (const marker of markers) {
			marker.addTo(map);
		}
		return;
	}
	fetch('https://www.paragliding-mapa.cz/api/v0.1/launch').then(response => response.json()).then(launch => {
		launchLoop: for (const site of launch.data) {
			for (const latLon in sites) {
				if (utils.isNear(getLatLon(latLon), {lat: site.latitude, lon: site.longitude})) {
					sites[latLon].push(site);
					continue launchLoop;
				}
			}
			sites[site.latitude + ' ' + site.longitude] = [site];
		}
		
		for (const latLon in sites) {
			const icon = newIcon(getIconUrl(sites[latLon], null), map.getZoom());
			const marker = L.marker(getLatLon(latLon), {icon, riseOnHover: true}).addTo(map);
			marker.bindPopup(getTooltip(sites[latLon]));
			marker.on('mouseover', () => marker.openPopup());
			marker.on('popupopen', () => loadForecast(latLon));
			markers[latLon] = marker;
		}
		
		redraw();
		broadcast.on('redrawFinished', redraw);
	});
};

this.onclose = () => {
	for (const marker of markers) {
		map.removeLayer(marker);
	}
};

function redraw() {
	interpolator(interpolate => {
		for (const latLon in markers) {
			if (map.getBounds().contains(getLatLon(latLon))) {
				let wind;
				if (store.get('overlay') == 'wind') {
					const data = interpolate(getLatLon(latLon));
					wind = data && utils.wind2obj(data);
				} else if (loadForecast(latLon)) {
					const data = getForecast(forecasts[getModel()][latLon]);
					wind = data && {wind: data.wind, dir: data.windDir};
				}
				delete winds[latLon];
				if (!wind) {
					const url = markers[latLon]._icon.src;
					markers[latLon].setIcon(newIcon(url, map.getZoom()));
				} else {
					updateMarker(latLon, wind);
				}
			}
		}
	});
}

function loadForecast(latLon) {
	const model = getModel();
	forecasts[model] = forecasts[model] || {};
	if (forecasts[model][latLon]) {
		return true;
	}
	loadData('forecast', Object.assign({model}, getLatLon(latLon))).then(forecast => {
		forecasts[model][latLon] = forecast.data;
		const data = getForecast(forecast.data);
		updateMarker(latLon, data && {wind: data.wind, dir: data.windDir});
	});
}

function updateMarker(latLon, wind) {
	winds[latLon] = winds[latLon] || wind;
	wind = winds[latLon];
	markers[latLon].setIcon(newIcon(getIconUrl(sites[latLon], wind), map.getZoom()));
	markers[latLon].setOpacity(getColor(sites[latLon], wind) != 'red' ? 1 : .4);
	markers[latLon].setPopupContent(getTooltip(sites[latLon]));
}

function getTooltip(sites) {
	let wind;
	let forecast;
	const tooltips = sites.map(site => {
		wind = wind || (winds[site.latitude + ' ' + site.longitude]);
		forecast = forecast || (forecasts[getModel()] && forecasts[getModel()][site.latitude + ' ' + site.longitude]);
		return '<a href="' + site.url + '" target="_blank">' + html(site.name) + '</a> (' + site.superelevation + ' m)<br>';
	});
	const extra = [];
	if (wind) {
		extra.push('<span style="display: inline-block; transform: rotate(' + wind.dir + 'deg)">↓</span> ' + wind.dir + '° ' + wind.wind.toFixed(1) + ' m/s');
	}
	if (forecast && !/FAKE/.test(forecast.header.note)) {
		const data = getForecast(forecast);
		if (data) {
			const sunrise = new Date(forecast.header.sunrise).getHours();
			const sunset = new Date(forecast.header.sunset).getHours();
			const icon = data.icon2 + (data.hour > sunrise && data.hour <= sunset ? '' : '_night_' + data.moonPhase);
			extra.push('<img src="img/icons4/png_25px/' + icon + '.png" style="height: 1.3em; vertical-align: middle;">' + (data.mm ? ' ' + data.mm + ' mm' : ''));
		}
	}
	return '<div style="min-width: 160px;">' + tooltips.join('') + extra.join(' ') + '</div>';
}

function getModel() {
	return store.get('product') == 'gfs' ? 'gfs' : 'ecmwf';
}

function getForecast(forecast) {
	const path = store.get('path').replace(/\//g, '-');
	const day = forecast.data[path.replace(/-\d+$/, '')] || [];
	let last;
	for (const data of day) {
		if (data.hour > path.replace(/.*-0?/, '')) {
			break;
		}
		last = data;
	}
	return last;
}

function getColor(sites, wind) {
	if (!wind) {
		return 'white';
	}
	if (wind.wind.toFixed(1) >= 8) {
		return 'red';
	}
	const dir = wind.dir;
	let color = 'red';
	for (const site of sites) {
		const from = site.wind_usable_from;
		const to = site.wind_usable_to;
		if (isDirIn(dir, from, to)) {
			return wind.wind.toFixed(1) >= 4 ? 'yellow' : 'lime';
		}
		if (isDirIn(dir, from, to, 10)) {
			color = 'yellow';
		}
	}
	return color;
}

function isDirIn(dir, from, to, tolerance = 0) {
	to += (to < from ? 360 : 0);
	return (dir >= from - tolerance && dir <= to + tolerance) || dir <= to + tolerance - 360 || dir >= from - tolerance + 360;
}

function getIconUrl(sites, wind) {
	let svg = '<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38">\n';
	for (const site of sites) {
		const color = getColor([site], wind);
		svg += (site.wind_usable_to - site.wind_usable_from >= 359
			? '<circle cx="19" cy="19" r="18" fill="' + color + '"/>'
			: getCircleSlice(site.wind_usable_from - 90, site.wind_usable_to - 90, 38, color)
		) + '\n';
	}
	svg += '<circle cx="19" cy="19" r="18" stroke="white" stroke-width="2" fill-opacity="0"/>\n</svg>';
	return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

function newIcon(url, zoom) {
	const size = zoom > 9 ? 38 : zoom > 6 ? 19 : zoom > 4 ? 9 : 5;
	return L.icon({
		iconUrl: url,
		iconSize: [size, size],
		iconAnchor: [(size - 1) / 2, (size - 1) / 2],
	});
}

function getCircleSlice(startAngle, endAngle, size, color) {
	const hSize = size / 2;
	const x1 = Math.round(hSize + hSize * Math.cos(Math.PI * startAngle / 180));
	const y1 = Math.round(hSize + hSize * Math.sin(Math.PI * startAngle / 180));
	const x2 = Math.round(hSize + hSize * Math.cos(Math.PI * endAngle / 180));
	const y2 = Math.round(hSize + hSize * Math.sin(Math.PI * endAngle / 180));
	return "<path d='M" + hSize + "," + hSize + " L" + x1 + "," + y1 + " A" + hSize + "," + hSize + " 0 0,1 " + x2 + "," + y2 + " Z' fill='" + color + "'/>";
}

function getLatLon(latLon) {
	const parts = latLon.split(' ');
	return {lat: +parts[0], lon: +parts[1]};
}

function html(s) {
	return s.replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
</script>
</plugin>
