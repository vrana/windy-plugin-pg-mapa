<plugin>
<script>
import broadcast from '@windy/broadcast';
import interpolator from '@windy/interpolator';
import map from '@windy/map';
import pluginDataLoader from '@windy/pluginDataLoader';
import store from '@windy/store';
import utils from '@windy/utils';

const loadData = pluginDataLoader({
	key: 'vVGMVsbSz6cWtZsxMPQURL88LKFYpojx',
	plugin: 'windy-plugin-pg-mapa',
});

/** @type {Object<string, Array<{
 *   latitude: number,
 *   longitude: number,
 *   name: string,
 *   url: string,
 *   superelevation: number,
 *   wind_usable_from: number,
 *   wind_usable_to: number,
 * }>>} key: latLon */
const sites = {};
/** @type {Object<string, L.marker>} key: latLon */
const markers = {};
/** @typedef {{wind: number, dir: number, gust: number|undefined}} */
let Wind;
/** @type {Object<string, Wind>} key: latLon */
const winds = {};
/** @typedef {{
 *   hour: number,
 *   wind: number,
 *   gust: number,
 *   windDir: number,
 *   icon2: number,
 *   moonPhase: number,
 *   mm: number,
 * }} */
let Forecast;
/** @type {Object<string, Object<string, {
 *   header: {note: string, sunrise: number, sunset: number},
 *   data: Object<string, Array<Forecast>>,
 * }>>} key: model, key2: latLon, key in data: day */
const forecasts = {};

this.onopen = () => {
	if (Object.keys(markers).length) {
		// Opening already loaded layer.
		for (const marker of markers) {
			marker.addTo(map);
		}
		return;
	}
	fetch('https://www.paragliding-mapa.cz/api/v0.1/launch').then(response => response.json()).then(launch => {
		launchLoop: for (const site of launch.data) {
			for (const latLon in sites) {
				if (utils.isNear(getLatLon(latLon), {lat: site.latitude, lon: site.longitude})) {
					// Merge two sites if they are close to each other, e.g. Raná SZ and Raná JV.
					sites[latLon].push(site);
					continue launchLoop;
				}
			}
			// Store latitude and longitude in one key to avoid having sites[latitude] = sites[latitude] || {}.
			sites[site.latitude + ' ' + site.longitude] = [site];
		}
		
		for (const latLon in sites) {
			const icon = newIcon(getIconUrl(sites[latLon], null), map.getZoom());
			const marker = L.marker(getLatLon(latLon), {icon, riseOnHover: true}).addTo(map);
			// Leaflet supports binding function but that function is called only the first time the popup is opened.
			marker.bindPopup(getTooltip(sites[latLon]), {minWidth: 160});
			// Leaflet tooltips close when you hover the tooltip and they work poorly on mobile. Use popup instead.
			marker.on('mouseover', () => marker.openPopup());
			marker.on('popupopen', () => loadForecast(latLon));
			markers[latLon] = marker;
		}
		
		redraw(); // Redraw might be finished before the data is loaded.
		broadcast.on('redrawFinished', redraw);
	});
};

function redraw() {
	interpolator(interpolate => {
		for (const latLon in markers) {
			if (map.getBounds().contains(getLatLon(latLon))) {
				let wind;
				if (store.get('overlay') == 'wind') {
					// If the displayed overlay is 'wind' then use it.
					const data = interpolate(getLatLon(latLon));
					wind = data && utils.wind2obj(data);
				} else if (loadForecast(latLon)) {
					// If we already have the forecast loaded then use it, otherwise loadForecast will use it.
					const data = getForecast(forecasts[getModel()][latLon]);
					wind = data && {wind: data.wind, dir: data.windDir, gust: data.gust};
				}
				delete winds[latLon]; // After switching overlays or model, update the stored wind.
				if (!wind) {
					// Preserve the old icon, just resize it.
					const url = markers[latLon]._icon.src;
					markers[latLon].setIcon(newIcon(url, map.getZoom()));
				} else {
					updateMarker(latLon, wind);
				}
			}
		}
	});
}

/** Loads forecast if not already loaded.
 * @param {string} latLon
 * @return {boolean} True if forecast is already loaded.
 */
function loadForecast(latLon) {
	const model = getModel();
	forecasts[model] = forecasts[model] || {};
	if (forecasts[model][latLon]) {
		return true;
	}
	loadData('forecast', Object.assign({model}, getLatLon(latLon))).then(forecast => {
		forecasts[model][latLon] = forecast.data;
		const data = getForecast(forecast.data);
		// After loading the forecast, update the tooltip and possibly also the icon.
		updateMarker(latLon, data && {wind: data.wind, dir: data.windDir, gust: data.gust});
	});
	return false;
}

/** Sets color, opacity and tooltip of a marker.
 * @param {string} latLon
 * @param {Wind} wind
 */
function updateMarker(latLon, wind) {
	winds[latLon] = winds[latLon] || wind; // If we already have wind from interpolator then keep it.
	winds[latLon].gust = wind.gust;
	wind = winds[latLon];
	markers[latLon].setIcon(newIcon(getIconUrl(sites[latLon], wind), map.getZoom()));
	markers[latLon].setOpacity(getColor(sites[latLon], wind) != 'red' ? 1 : .4);
	markers[latLon].setPopupContent(getTooltip(sites[latLon]));
}

/** Gets tooltip with site names, wind info and forecast.
 * @param {Array<{latitude: number, longitude: number, name: string, url: string, superelevation: number}>} sites
 * @return {string} HTML.
 */
function getTooltip(sites) {
	let wind;
	let forecast;
	const tooltips = sites.map(site => {
		// Site latLon might be slightly different from wind latLon due to a utils.isNear call. However one will eventually match.
		wind = wind || (winds[site.latitude + ' ' + site.longitude]);
		forecast = forecast || (forecasts[getModel()] && forecasts[getModel()][site.latitude + ' ' + site.longitude]);
		return '<a href="' + site.url + '" target="_blank">' + html(site.name) + '</a> ' + site.altitude + ' mnm (' + site.superelevation + ' m)<br>';
	});
	const extra = [];
	if (wind) {
		const colors = ['green', 'orange', 'red'];
		extra.push('<a href=\'javascript:W.store.set("detailDisplay", "wind"); W.broadcast.fire("rqstOpen", "detail", {lat: ' + sites[0].latitude + ', lon: ' + sites[0].longitude + '});\'>'
			+ '<span style="color: ' + colors[getDirIndex(sites, wind.dir)] + ';"><span style="display: inline-block; transform: rotate(' + wind.dir + 'deg)">↓</span> ' + wind.dir + '°</span>'
			+ ' <span style="color: ' + colors[getSpeedIndex(wind.wind)] + ';"' + (wind.gust != null ? ' title="gust: ' + wind.gust.toFixed(1) + ' m/s"' : '') + '>' + wind.wind.toFixed(1) + ' m/s</span>'
			+ '</a>');
	}
	if (forecast && !/FAKE/.test(forecast.header.note)) {
		const data = getForecast(forecast);
		if (data) {
			// We don't have data about twilight, use sunrise and sunset instead.
			const sunrise = new Date(forecast.header.sunrise).getHours();
			const sunset = new Date(forecast.header.sunset).getHours();
			const icon = data.icon2 + (data.hour > sunrise && data.hour <= sunset ? '' : '_night_' + data.moonPhase);
			const href = 'href=\'javascript:W.store.set("detailDisplay", "table"); W.broadcast.fire("rqstOpen", "detail", {lat: ' + sites[0].latitude + ', lon: ' + sites[0].longitude + '});\'';
			extra.push('<a ' + href + '><img src="img/icons4/png_25px/' + icon + '.png" style="height: 1.3em; vertical-align: middle;"></a>' + (data.mm ? ' ' + data.mm + ' mm' : ''));
		}
	}
	return tooltips.join('') + extra.join(' ');
}

/** Gets model usable for forecast.
 * @return {string}
 */
function getModel() {
	return store.get('product') == 'gfs' ? 'gfs' : 'ecmwf';
}

/** Gets forecast for current time.
 * @param {{data: Object<string, Array<Forecast>>}} forecast Loaded forecast.data.
 * @return {?Forecast} Null if there's no forecast.
 */
function getForecast(forecast) {
	// The format of 'path' is year/month/day/hour.
	const path = store.get('path').replace(/\//g, '-');
	const day = forecast.data[path.replace(/-\d+$/, '')] || [];
	let last = null;
	for (const data of day) {
		// The granularity of forecast is 3 hours but GFS can be stepped by 1 hour. Use last non-future forecast (e.g. 21:00 forecast for 23:00 path).
		if (data.hour > path.replace(/.*-0?/, '')) {
			break;
		}
		last = data;
	}
	return last;
}

/** Gets URL with SVG image.
 * @param {Array<{wind_usable_from: number, wind_usable_to: number}>} sites
 * @param {Wind} wind
 * @return {string}
 */
function getIconUrl(sites, wind) {
	let svg = '<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38">\n';
	for (const site of sites) {
		const color = getColor([site], wind);
		svg += (site.wind_usable_to - site.wind_usable_from >= 359
			? '<circle cx="19" cy="19" r="18" fill="' + color + '"/>'
			: getCircleSlice(site.wind_usable_from - 90, site.wind_usable_to - 90, 38, color)
		) + '\n';
	}
	svg += '<circle cx="19" cy="19" r="18" stroke="#333" stroke-width="2" fill-opacity="0"/>\n</svg>';
	return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

/** Gets color for wind.
 * @param {Array<{wind_usable_from: number, wind_usable_to: number}>} sites
 * @param {Wind} wind
 * @return {string}
 */
function getColor(sites, wind) {
	if (!wind) {
		return 'white';
	}
	const colors = ['lime', 'yellow', 'red'];
	return colors[Math.max(getSpeedIndex(wind.wind), getDirIndex(sites, wind.dir))];
}

/** Gets color index for wind speed.
 * @param {number} speed
 * @return {int} 0 good, 1 stronger, 2 too strong
 */
function getSpeedIndex(speed) {
	if (speed.toFixed(1) >= 8) { // Round here to not have 7.99 displayed as 8 shown in yellow.
		return 2;
	} else if (speed.toFixed(1) >= 4) {
		return 1;
	}
	return 0;
}

/** Gets color index for wind direction.
 * @param {Array<{wind_usable_from: number, wind_usable_to: number}>} sites
 * @param {number} dir
 * @return {int} 0 good, 1 almost, 2 bad
 */
function getDirIndex(sites, dir) {
	let result = 2;
	for (const site of sites) {
		const from = site.wind_usable_from;
		const to = site.wind_usable_to;
		if (isDirIn(dir, from, to)) {
			return 0;
		} else if (isDirIn(dir, from, to, 10)) {
			result = 1;
		}
	}
	return result;
}

/** Checks whether dir is between from and to with tolerance.
 * @param {number} dir Range <0, 360).
 * @param {number} from Range <0, 360).
 * @param {number} to Range <0, 360>.
 * @param {number} tolerance Range <0, 360).
 * @return {boolean}
 */
function isDirIn(dir, from, to, tolerance = 0) {
	to += (to < from ? 360 : 0);
	return (dir >= from - tolerance && dir <= to + tolerance) || dir <= to + tolerance - 360 || dir >= from - tolerance + 360;
}

/** Creates new icon.
 * @param {string} url
 * @param {number} zoom
 * @return {L.icon}
 */
function newIcon(url, zoom) {
	const size = zoom > 9 ? 38 : zoom > 6 ? 19 : zoom > 4 ? 9 : 5;
	return L.icon({
		iconUrl: url,
		iconSize: [size, size],
		iconAnchor: [(size - 1) / 2, (size - 1) / 2],
	});
}

/** Gets SVG path for circle slice.
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} size
 * @param {string} color
 * @return {string}
 */
function getCircleSlice(startAngle, endAngle, size, color) {
	const hSize = size / 2;
	const x1 = hSize + hSize * Math.cos(Math.PI * startAngle / 180);
	const y1 = hSize + hSize * Math.sin(Math.PI * startAngle / 180);
	const x2 = hSize + hSize * Math.cos(Math.PI * endAngle / 180);
	const y2 = hSize + hSize * Math.sin(Math.PI * endAngle / 180);
	const largeArc = (endAngle - startAngle + 360) % 360 > 180 ? 1 : 0;
	return '<path d="M' + hSize + ',' + hSize + ' L' + x1 + ',' + y1 + ' A' + hSize + ',' + hSize + ' 0 ' + largeArc + ' 1 ' + x2 + ',' + y2 + ' Z" fill="' + color + '"/>';
}

/** Gets {lat, lon} object.
 * @param {string} Latitude and longitude separated with space.
 * @return {{lat: number, lon: number}}
 */
function getLatLon(latLon) {
	const parts = latLon.split(' ');
	return {lat: +parts[0], lon: +parts[1]};
}

/** Escapes special HTML characters.
 * @param {string} text
 * @return {string}
 */
function html(text) {
	return text.replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
</script>
</plugin>
