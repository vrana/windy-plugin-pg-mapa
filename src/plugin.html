<plugin>
<script>
import broadcast from '@windy/broadcast';
import interpolator from '@windy/interpolator';
import map from '@windy/map';
import pluginDataLoader from '@windy/pluginDataLoader';
import store from '@windy/store';
import utils from '@windy/utils';

const loadData = pluginDataLoader({
	key: 'vVGMVsbSz6cWtZsxMPQURL88LKFYpojx',
	plugin: 'windy-plugin-pg-mapa',
});

function onLaunchLoad() {
}

/** Gets model usable for forecast.
 * @return {string}
 */
function getModel() {
	const product = store.get('product');
	// https://github.com/windycom/windy-plugins/blob/master/docs/WINDY_API.md#module-plugindataloader
	return product == 'gfs' || product == 'iconEu' ? product : 'ecmwf';
}

function getLaunchAttrs(site) {
	return ' href="' + site.url + '" target="_blank"';
}

function getApiRoot() {
	return 'https://www.paragliding-mapa.cz/';
}

function getLaunchExtra(site) {
	return '';
}

function getWindAttrs(lat, lon) {
	return ' href=\'javascript:W.store.set("detailDisplay", "wind"); W.broadcast.fire("rqstOpen", "detail", {lat: ' + lat + ', lon: ' + lon + '});\'';
}

function getForecastAttrs(lat, lon) {
	return ' href=\'javascript:W.store.set("detailDisplay", "meteogram"); W.broadcast.fire("rqstOpen", "detail", {lat: ' + lat + ', lon: ' + lon + '});\'';
}

this.onopen = function () {
	const openInApp = document.getElementById('open-in-app');
	if (openInApp) {
		openInApp.style.display = 'none';
	}
	init();
}

// Same as https://pg.vrana.cz/mapa/ from here.

/** @typedef {{
 *   latitude: number,
 *   longitude: number,
 *   name: string,
 *   url: string,
 *   superelevation: number,
 *   flying_status: number,
 *   active: number,
 *   wind_usable_from: number,
 *   wind_usable_to: number,
 *   link_meteo: string,
 * }} */
let Site;
/** @type {Object<string, Array<Site>>} key: latLon */
const sites = {};
/** @type {Object<string, L.Marker>} key: latLon */
const markers = {};
/** @type {?L.Marker} */
let activeMarker = null;
/** @typedef {{wind: number, dir: number}} */
let Wind;
/** @type {Object<string, Wind>} key: model:level:path:latLon */
const winds = {};
/** @typedef {{
 *   hour: number,
 *   wind: number,
 *   gust: number,
 *   windDir: number,
 *   icon2: number,
 *   moonPhase: number,
 *   mm: number,
 * }} */
let Forecast;
/** @type {Object<string, Object<string, {
 *   header: {note: string, sunrise: number, sunset: number},
 *   data: Object<string, Array<Forecast>>,
 * }>>} key: model, key2: latLon, key in data: day */
const forecasts = {};
/** @typedef {{header: {modelElevation: number, elevation: number}, data: {
 *   hours: Array<number>,
 *   dewpoint-surface: Array<number>,
 *   temp-surface: Array<number>,
 *   temp-1000h: Array<number>,
 *   gh-1000h: Array<number>,
 * }}}
 */
let AirData;
/** @type {Object<string, Object<string, AirData>>} key: model, key2: latLon */
const airDatas = {};

function init() {
	if (Object.keys(markers).length) {
		// Opening already loaded layer.
		return;
	}
	fetch(getApiRoot() + 'api/v0.1/launch?locale=' + translate('en', 'cs')).then(response => response.json()).then(launch => {
		launchLoop: for (const site of launch.data) {
			for (const latLon in sites) {
				if (utils.isNear(getLatLon(latLon), {lat: site.latitude, lon: site.longitude})) {
					// Merge two sites if they are close to each other, e.g. Raná SZ and Raná JV.
					sites[latLon].push(site);
					continue launchLoop;
				}
			}
			// Store latitude and longitude in one key to avoid having sites[latitude] = sites[latitude] || {}.
			sites[site.latitude + ' ' + site.longitude] = [site];
		}

		for (const latLon in sites) {
			const icon = newIcon(getIconUrl(sites[latLon], null), map.getZoom());
			const marker = L.marker(getLatLon(latLon), {icon, riseOnHover: true, title: sites[latLon].map(site => site.name).join('\n')}).addTo(map);
			// Leaflet supports binding function but that function is called only the first time the popup is opened.
			marker.bindPopup(getTooltip(sites[latLon]), {minWidth: 200, maxWidth: 400});
			// Leaflet tooltips close when you hover the tooltip and they work poorly on mobile. Use popup instead.
			marker.on('popupopen', () => {
				activeMarker = marker;
				loadForecast(latLon);
				const model = getModel();
				airDatas[model] = airDatas[model] || {};
				if (!airDatas[model][latLon]) {
					loadData('airData', Object.assign({model}, getLatLon(latLon))).then(airData => {
						// Cache: response has Expires: -1.
						airDatas[model][latLon] = airData.data;
						markers[latLon].setPopupContent(getTooltip(sites[latLon]));
					});
				}
			});
			markers[latLon] = marker;
		}
		map.on('popupclose', () => activeMarker = null);

		redraw(); // Redraw might be finished before the data is loaded.
		broadcast.on('redrawFinished', redraw);
		onLaunchLoad();
	});
}

function redraw() {
	interpolator(interpolate => {
		for (const latLon in markers) {
			if (map.getBounds().contains(getLatLon(latLon))) {
				if (!winds[getWindsKey(latLon)]) {
					if (store.get('overlay') == 'wind') {
						// If the displayed overlay is 'wind' then use it.
						const data = interpolate(getLatLon(latLon));
						winds[getWindsKey(latLon)] = data && utils.wind2obj(data);
					} else if (!loadForecast(latLon)) {
						// Preserve the old icon, just resize it.
						const url = markers[latLon]._icon.src;
						markers[latLon].setIcon(newIcon(url, map.getZoom()));
						continue;
					}
				}
				updateMarker(latLon);
			}
		}
		if (activeMarker) {
			activeMarker.fire('popupopen');
		}
	});
}

/** Loads forecast if not already loaded.
 * @param {string} latLon
 * @return {boolean} True if forecast is already loaded.
 */
function loadForecast(latLon) {
	const model = getModel();
	forecasts[model] = forecasts[model] || {};
	if (forecasts[model][latLon]) {
		return true;
	}
	loadData('forecast', Object.assign({model}, getLatLon(latLon))).then(forecast => {
		forecasts[model][latLon] = forecast.data;
		// After loading the forecast, update the tooltip and possibly also the icon.
		updateMarker(latLon);
	});
	return false;
}

/** Gets wind data.
 * @param {string} latLon
 * @return {?Wind}
 */
function getWind(latLon) {
	if (winds[getWindsKey(latLon)]) {
		return winds[getWindsKey(latLon)];
	}
	const data = forecasts[getModel()] && forecasts[getModel()][latLon] && getForecast(forecasts[getModel()][latLon]);
	return data && {wind: data.wind, dir: data.windDir};
}

/** Sets color, opacity and tooltip of a marker.
 * @param {string} latLon
 */
function updateMarker(latLon) {
	const wind = getWind(latLon);
	markers[latLon].setIcon(newIcon(getIconUrl(sites[latLon], wind), map.getZoom()));
	markers[latLon].setOpacity(getColor(sites[latLon], wind) != 'red' ? 1 : .4);
	markers[latLon].setPopupContent(getTooltip(sites[latLon]));
}

/** Gets tooltip with site names, wind info and forecast.
 * @param {Array<{latitude: number, longitude: number, name: string, url: string, superelevation: number}>} sites
 * @return {string} HTML.
 */
function getTooltip(sites) {
	let wind;
	let forecast;
	let airData;
	const model = getModel();
	const tooltips = sites.map(site => {
		// Site latLon might be slightly different from wind latLon due to a utils.isNear call. However one will eventually match.
		const latLon = site.latitude + ' ' + site.longitude;
		wind = wind || getWind(latLon);
		forecast = forecast || (forecasts[model] && forecasts[model][latLon]);
		airData = airData || (airDatas[model] && airDatas[model][latLon]);
		return '<b style="font-size: 1.25em;"><a' + getLaunchAttrs(site)
			+ (isSiteForbidden(site) ? ' style="color: red;" title="' + translate('flying forbidden', 'létání zakázáno') + '"' : '') + '>' + html(site.name) + '</a></b>'
			+ ' <span title="' + translate('elevation', 'nadmořská výška') + '">' + site.altitude + ' ' + translate('masl', 'mnm') + '</span>'
			+ ' (<span title="' + translate('vertical metre', 'převýšení') + '">' + site.superelevation + ' m</span>)'
			+ getLaunchExtra(site)
		;
	});
	const data = forecast && !/FAKE/.test(forecast.header.note) && getForecast(forecast);
	let extra = [];
	if (wind) {
		const colors = ['green', 'orange', 'red'];
		// TODO: Get the high wind from airData for the other overlays.
		const windHeight = ' ' + (store.get('level') == 'surface' || store.get('overlay') != 'wind' ? translate('on surface', 'na zemi') : translate('at', 'v') + ' ' + store.get('level'));
		extra.push('<a' + getWindAttrs(sites[0].latitude, sites[0].longitude) + '>'
			+ '<span style="color: ' + colors[getDirIndex(sites, wind.dir)] + ';" title="' + translate('wind direction', 'směr větru') + windHeight + '">'
			+ '<span style="display: inline-block; transform: rotate(' + wind.dir + 'deg)">↓</span> ' + wind.dir + '°</span>'
			+ ' <span style="color: ' + colors[getSpeedIndex(wind.wind)] + ';" title="' + translate('wind speed', 'rychlost větru') + windHeight + '">' + wind.wind.toFixed(1) + ' m/s'
			+ (data && data.gust != null ? ',</span> <span style="color: ' + colors[getSpeedIndex(data.gust - 4)] + ';" title="' + translate('gusts on surface', 'nárazy na zemi') + '">G: ' + data.gust.toFixed(1) + ' m/s' : '')
			+ '</span></a>');
	}
	if (data) {
		// We don't have data about twilight, use sunrise and sunset instead.
		const sunrise = new Date(forecast.header.sunrise).getHours();
		const sunset = new Date(forecast.header.sunset).getHours();
		const icon = data.icon2 + (data.hour > sunrise && data.hour <= sunset ? '' : '_night_' + data.moonPhase);
		extra.push('<a' + getForecastAttrs(sites[0].latitude, sites[0].longitude) + '>'
			+ '<img src="https://www.windy.com/img/icons4/png_25px/' + icon + '.png" style="height: 1.3em; vertical-align: middle;" title="' + translate('weather', 'počasí') + ' ' + model + '"></a>'
			+ (data.mm ? ' <span title="' + translate('precipitation', 'srážky') + '">' + data.mm + ' mm</span>' : '')
		);
	}
	tooltips.push(extra.join(' '));
	const p = sites[0].longitude + 'x' + sites[0].latitude;
	const t = store.get('path').replace(/\//g, '-').replace(/-(\d+)$/, (match, hour) => 'T' + String(Math.round(hour / 3) * 3).padStart(2, 0) + ':00:00Z');
	let s = sites[0].name;
	if (sites.length > 1) {
		const words = {};
		for (const site of sites) {
			site.name.split(/[- ,.]+/).forEach(word => words[word] = (words[word] || 0) + 1);
		}
		const names = Object.keys(words).filter(word => words[word] == sites.length);
		s = names.length ? names.join(' ') : s;
	}
	extra = [];
	const meteoLinks = sites[0].link_meteo.match(/https?:\/\/\S+/g);
	meteoLinks && meteoLinks.forEach(link => extra.push('<a href="' + link + '" class="iconfont" style="vertical-align: middle;" title="' + translate('weather station', 'meteostanice') + '" target="_blank"></a>'));
	const webcamLinks = sites[0].link_webcam.match(/https?:\/\/\S+/g);
	webcamLinks && webcamLinks.forEach(link => extra.push('<a href="' + link + '" class="iconfont" style="vertical-align: middle;" title="' + translate('webcam', 'webkamera') + '" target="_blank">l</a>'));
	extra.push('<span title="' + translate('lower from intersections of dry adiabat with temperature and isogram', 'nižší z průsečíků suché adiabaty s teplotou a izogramou') + '">'
		+ translate('Possible climb', 'Dostupy') + '</span>:'
		+ ' <a href="http://www.xcmeteo.net/?p=' + p + ',t=' + t + ',s=' + encodeURIComponent(s) + '" target="_blank" title="' + translate('source', 'zdroj') + ': Windy ' + getModel() + '">'
		+ (airData ? Math.round(computeCeiling(airData) / 10) * 10 + ' m' : '-')
		+ '</a>'
	);
	tooltips.push(extra.join(' '));
	return '<div style="white-space: nowrap;">' + tooltips.join('<br>') + '</div>';
}

/** Gets forecast for current time.
 * @param {{data: Object<string, Array<Forecast>>}} forecast Loaded forecast.data.
 * @return {?Forecast} Null if there's no forecast.
 */
function getForecast(forecast) {
	// The format of 'path' is YYYY/MM/DD/HH.
	const path = store.get('path').replace(/\//g, '-');
	const day = forecast.data[path.replace(/-\d+$/, '')] || [];
	let last = null;
	for (const data of day) {
		// Use last non-future forecast (e.g. 21:00 forecast for 23:00 path with 3 hours granularity).
		if (data.hour > path.replace(/.*-0?/, '')) {
			break;
		}
		last = data;
	}
	return last;
}

/** Gets URL with SVG image.
 * @param {Array<Site>} sites
 * @param {Wind} wind
 * @return {string}
 */
function getIconUrl(sites, wind) {
	let svg = '<svg xmlns="http://www.w3.org/2000/svg" width="38" height="38">\n';
	for (const site of sites) {
		const color = getColor([site], wind);
		svg += (site.wind_usable_to - site.wind_usable_from >= 359
			? '<circle cx="19" cy="19" r="18" fill="' + color + '"/>'
			: getCircleSlice(site.wind_usable_from - 90, site.wind_usable_to - 90, 38, color)
		) + '\n';
	}
	svg += '<circle cx="19" cy="19" r="18" stroke="#333" stroke-width="2" fill-opacity="0"/>\n</svg>';
	return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}

/** Gets color for wind.
 * @param {Array<Site>} sites
 * @param {Wind} wind
 * @return {string}
 */
function getColor(sites, wind) {
	const colors = ['lime', 'yellow', 'red'];
	if (sites.every(isSiteForbidden)) {
		return colors[2];
	}
	if (!wind) {
		return 'white';
	}
	return colors[Math.max(getSpeedIndex(wind.wind), getDirIndex(sites, wind.dir))];
}

/** Checks if site forbidden.
 * @param {Site} site
 * @return {boolean}
 */
function isSiteForbidden(site) {
	return (site.flying_status == 4 || site.active == 0);
}

/** Gets color index for wind speed.
 * @param {number} speed
 * @return {int} 0 good, 1 stronger, 2 too strong
 */
function getSpeedIndex(speed) {
	if (speed.toFixed(1) >= 8) { // Round here to not have 7.99 displayed as 8 shown in yellow.
		return 2;
	} else if (speed.toFixed(1) >= 4) {
		return 1;
	}
	return 0;
}

/** Gets color index for wind direction.
 * @param {Array<Site>} sites
 * @param {number} dir
 * @return {int} 0 good, 1 almost, 2 bad
 */
function getDirIndex(sites, dir) {
	let result = 2;
	for (const site of sites) {
		if (isSiteForbidden(site)) {
			continue;
		}
		const from = site.wind_usable_from;
		const to = site.wind_usable_to;
		if (isDirIn(dir, from, to)) {
			return 0;
		} else if (isDirIn(dir, from, to, 10)) {
			result = 1;
		}
	}
	return result;
}

/** Checks whether dir is between from and to with tolerance.
 * @param {number} dir Range <0, 360).
 * @param {number} from Range <0, 360).
 * @param {number} to Range <0, 360>.
 * @param {number} tolerance Range <0, 360).
 * @return {boolean}
 */
function isDirIn(dir, from, to, tolerance = 0) {
	to += (to < from ? 360 : 0);
	return (dir >= from - tolerance && dir <= to + tolerance) || dir <= to + tolerance - 360 || dir >= from - tolerance + 360;
}

/** Creates new icon.
 * @param {string} url
 * @param {number} zoom
 * @return {L.Icon}
 */
function newIcon(url, zoom) {
	const size = zoom > 9 ? 38 : zoom > 6 ? 19 : zoom > 4 ? 9 : 5;
	return L.icon({
		iconUrl: url,
		iconSize: [size, size],
		iconAnchor: [(size - 1) / 2, (size - 1) / 2],
	});
}

/** Gets SVG path for circle slice.
 * @param {number} startAngle
 * @param {number} endAngle
 * @param {number} size
 * @param {string} color
 * @return {string}
 */
function getCircleSlice(startAngle, endAngle, size, color) {
	const hSize = size / 2;
	const x1 = hSize + hSize * Math.cos(Math.PI * startAngle / 180);
	const y1 = hSize + hSize * Math.sin(Math.PI * startAngle / 180);
	const x2 = hSize + hSize * Math.cos(Math.PI * endAngle / 180);
	const y2 = hSize + hSize * Math.sin(Math.PI * endAngle / 180);
	const largeArc = (endAngle - startAngle + 360) % 360 > 180 ? 1 : 0;
	return '<path d="M' + hSize + ',' + hSize + ' L' + x1 + ',' + y1 + ' A' + hSize + ',' + hSize + ' 0 ' + largeArc + ' 1 ' + x2 + ',' + y2 + ' Z" fill="' + color + '"/>';
}

/** Gets {lat, lon} object.
 * @param {string} Latitude and longitude separated with space.
 * @return {{lat: number, lon: number}}
 */
function getLatLon(latLon) {
	const parts = latLon.split(' ');
	return {lat: +parts[0], lon: +parts[1]};
}

/** Gets key used for winds cache.
 * @param {string} latLon
 * @return {string}
 */
function getWindsKey(latLon) {
	return (store.get('overlay') == 'wind' ? store.get('product') + ':' + store.get('level') : getModel() + ':surface')
		+ ':' + store.get('path')
		+ ':' + latLon
	;
}

/** Computes ceiling: min(dry abiabat crossing humidity, temperature crossing dry adiabat).
 * @param {AirData} airData
 * @return number Altitude in meters
 */
function computeCeiling(airData) {
	const {header, data} = airData;
	// The format of 'path' is YYYY/MM/DD/HH.
	const now = new Date(store.get('path').replace(/\//g, '-').replace(/-(\d+)$/, 'T$1:00Z')).getTime();
	let hour = 0;
	for (const key in data.hours) {
		if (data.hours[key] > now) {
			break;
		}
		hour = key;
	}
	const elevation = header.modelElevation || header.elevation;
	let dryAdiabatTemp = data['temp-surface'][hour];
	// TODO: This depends on pressure: http://slovnik.cmes.cz/heslo/9
	const cloudBase = elevation + (dryAdiabatTemp - data['dewpoint-surface'][hour]) * 122;
	const layers = {temp: {}, gh: {}};
	for (const key in data) {
		const match = /^(temp|gh)-(\d+)h$/.exec(key);
		if (match) {
			layers[match[1]][match[2]] = data[key][hour];
		}
	}
	let ceiling = elevation;
	let prevTemp = dryAdiabatTemp;
	Object.keys(layers.temp).sort((a, b) => b - a).some(pressure => {
		const gh = layers.gh[pressure];
		if (gh > ceiling) {
			const temp = layers.temp[pressure];
			const height = gh - ceiling;
			if (temp > dryAdiabatTemp - height * .01) {
				// X = -.01 * Y + dryAdiabatTemp
				// X = ((temp - prevTemp) / height) * Y + prevTemp
				// -.01 * Y + dryAdiabatTemp = ((temp - prevTemp) / height) * Y + prevTemp
				// (((temp - prevTemp) / height) + .01) * Y = dryAdiabatTemp - prevTemp
				// Y = (dryAdiabatTemp - prevTemp) / (((temp - prevTemp) / height) + .01)
				ceiling += (dryAdiabatTemp - prevTemp) / (((temp - prevTemp) / height) + .01);
				return true;
			}
			dryAdiabatTemp -= height * .01;
			ceiling = gh;
			prevTemp = temp;
		}
	});
	return Math.min(ceiling, cloudBase);
}

/** Gets translation.
 * @param {string} english
 * @param {string} czech
 * @return {string}
 */
function translate(english, czech) {
	const lang = store.get('lang');
	return (lang == 'auto' ? store.get('usedLang') : lang) == 'cs' ? czech : english;
}

/** Escapes special HTML characters.
 * @param {string} text
 * @return {string}
 */
function html(text) {
	return text.replace(/&/g, '&amp;').replace(/</g, '&lt;');
}
</script>
</plugin>
